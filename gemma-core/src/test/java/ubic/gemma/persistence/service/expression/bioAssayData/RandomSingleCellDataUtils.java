package ubic.gemma.persistence.service.expression.bioAssayData;

import cern.jet.random.NegativeBinomial;
import org.springframework.util.Assert;
import ubic.gemma.model.common.description.Categories;
import ubic.gemma.model.common.description.Characteristic;
import ubic.gemma.model.common.quantitationtype.*;
import ubic.gemma.model.expression.arrayDesign.ArrayDesign;
import ubic.gemma.model.expression.bioAssay.BioAssay;
import ubic.gemma.model.expression.bioAssayData.CellTypeAssignment;
import ubic.gemma.model.expression.bioAssayData.SingleCellDimension;
import ubic.gemma.model.expression.bioAssayData.SingleCellExpressionDataVector;
import ubic.gemma.model.expression.biomaterial.BioMaterial;
import ubic.gemma.model.expression.designElement.CompositeSequence;
import ubic.gemma.model.expression.experiment.ExpressionExperiment;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Utilities for generating random single-cell data.
 * @author poirigui
 * @see RandomExpressionDataMatrixUtils
 * @see RandomBulkDataUtils
 */
public class RandomSingleCellDataUtils {

    private static final Random random = new Random();

    /**
     * Set the seed used to generate random single-cell vectors.
     */
    public static void setSeed( long seed ) {
        RandomDataUtils.setSeed( seed );
        random.setSeed( seed );
    }

    public static List<SingleCellExpressionDataVector> randomSingleCellVectors() {
        return randomSingleCellVectors( 100, 4, 1000, 0.9, ScaleType.COUNT );
    }

    public static List<SingleCellExpressionDataVector> randomSingleCellVectors( QuantitationType quantitationType ) {
        ArrayDesign arrayDesign = new ArrayDesign();
        for ( int i = 0; i < 100; i++ ) {
            arrayDesign.getCompositeSequences().add( CompositeSequence.Factory.newInstance( "cs" + i ) );
        }
        ExpressionExperiment ee = new ExpressionExperiment();
        for ( int i = 0; i < 4; i++ ) {
            BioMaterial bm = BioMaterial.Factory.newInstance( "bm" + i );
            BioAssay ba = BioAssay.Factory.newInstance( "ba" + i, arrayDesign, bm );
            bm.getBioAssaysUsedIn().add( ba );
            ee.getBioAssays().add( ba );
        }
        return randomSingleCellVectors( ee, arrayDesign, quantitationType, 1000, 0.9 );
    }

    public static List<SingleCellExpressionDataVector> randomSingleCellVectors( int numDesignElements, int numSamples, int numCellsPerBioAssay, double sparsity, ScaleType scaleType ) {
        QuantitationType qt = new QuantitationType();
        qt.setGeneralType( GeneralType.QUANTITATIVE );
        qt.setType( StandardQuantitationType.COUNT );
        qt.setScale( scaleType );
        qt.setRepresentation( PrimitiveType.DOUBLE );
        return randomSingleCellVectors( numDesignElements, numSamples, numCellsPerBioAssay, sparsity, qt );
    }

    public static List<SingleCellExpressionDataVector> randomSingleCellVectors( int numDesignElements, int numSamples, int numCellsPerBioAssay, double sparsity, QuantitationType qt ) {
        ArrayDesign arrayDesign = new ArrayDesign();
        for ( int i = 0; i < numDesignElements; i++ ) {
            arrayDesign.getCompositeSequences().add( CompositeSequence.Factory.newInstance( "cs" + i, arrayDesign ) );
        }
        ExpressionExperiment ee = new ExpressionExperiment();
        for ( int i = 0; i < numSamples; i++ ) {
            BioMaterial bm = BioMaterial.Factory.newInstance( "bm" + i );
            BioAssay ba = BioAssay.Factory.newInstance( "ba" + i, arrayDesign, bm );
            bm.getBioAssaysUsedIn().add( ba );
            ee.getBioAssays().add( ba );
        }
        return randomSingleCellVectors( ee, arrayDesign, qt );
    }

    /**
     * Generate random single-cell vectors with 1000 cells/sample and 90% sparsity.
     * @see #randomSingleCellVectors(ExpressionExperiment, ArrayDesign, QuantitationType, int, double)
     */
    public static List<SingleCellExpressionDataVector> randomSingleCellVectors( ExpressionExperiment ee, ArrayDesign ad, QuantitationType qt ) {
        return randomSingleCellVectors( ee, ad, qt, 1000, 0.9 );
    }

    /**
     * Generate random single-cell vectors.
     * <p>
     * Counts are drawn from a {@link NegativeBinomial}.
     * <p>
     * One vector is generated by design element from the provided array design with the given sparsity.
     * @param numCellsPerBioAssay how many cells to generate per {@link BioAssay}
     * @param sparsity            sparsity of the vectors
     */
    public static List<SingleCellExpressionDataVector> randomSingleCellVectors( ExpressionExperiment ee, ArrayDesign ad, QuantitationType qt, int numCellsPerBioAssay, double sparsity ) {
        Assert.isTrue( sparsity >= 0.0 && sparsity <= 1.0, "Sparsity must be between 0 and 1." );
        SingleCellDimension dimension = createDimension( ee, numCellsPerBioAssay );
        // necessary for reproducible results
        List<CompositeSequence> sortedCs = new ArrayList<>( ad.getCompositeSequences() );
        sortedCs.sort( Comparator.comparing( CompositeSequence::getName ) );
        List<SingleCellExpressionDataVector> results = new ArrayList<>();
        for ( CompositeSequence compositeSequence : sortedCs ) {
            SingleCellExpressionDataVector vector = randomSingleCellVector( ee, compositeSequence, qt, dimension, sparsity );
            results.add( vector );
        }
        return results;
    }

    public static SingleCellExpressionDataVector randomSingleCellVector( ExpressionExperiment ee, CompositeSequence compositeSequence, QuantitationType qt, int numCellsPerBioAssay, double sparsity ) {
        return randomSingleCellVector( ee, compositeSequence, qt, createDimension( ee, numCellsPerBioAssay ), sparsity );
    }

    /**
     * Generate a single random single-cell vector.
     */
    public static SingleCellExpressionDataVector randomSingleCellVector( ExpressionExperiment ee, CompositeSequence compositeSequence, QuantitationType qt, SingleCellDimension dimension, double sparsity ) {
        Assert.isTrue( qt.getGeneralType() == GeneralType.QUANTITATIVE,
                "Can only generate quantitative data." );
        Assert.isTrue( qt.getType() == StandardQuantitationType.COUNT || qt.getType() == StandardQuantitationType.AMOUNT );
        Assert.isTrue( qt.getScale() == ScaleType.COUNT || qt.getScale() == ScaleType.LINEAR
                        || qt.getScale() == ScaleType.LOG2 || qt.getScale() == ScaleType.LOG1P
                        || qt.getScale() == ScaleType.PERCENT || qt.getScale() == ScaleType.PERCENT1,
                "Unsupported scale type for random data vectors: " + qt.getScale() );
        SingleCellExpressionDataVector vector = new SingleCellExpressionDataVector();
        vector.setExpressionExperiment( ee );
        vector.setDesignElement( compositeSequence );
        vector.setQuantitationType( qt );
        vector.setSingleCellDimension( dimension );
        double density = 1.0 - sparsity;
        int N = ( int ) Math.ceil( density * dimension.getNumberOfCellIds() );
        int step = ( int ) ( 1.0 / density );
        switch ( qt.getRepresentation() ) {
            case FLOAT:
                setRandomFloatData( vector, qt, step, N );
                break;
            case DOUBLE:
                setRandomDoubleData( vector, qt, step, N );
                break;
            case INT:
                setRandomIntData( vector, qt, step, N );
                break;
            case LONG:
                setRandomLongData( vector, qt, step, N );
                break;
            default:
                throw new UnsupportedOperationException( "Sampling " + qt.getRepresentation() + " is not supported." );
        }
        return vector;
    }

    /**
     * Generate a random cell type assignment with 10 cell types and 10% sparsity.
     */
    public static CellTypeAssignment randomCellTypeAssignment( SingleCellDimension scd ) {
        return randomCellTypeAssignment( scd, 10, 0.1 );
    }

    public static CellTypeAssignment randomCellTypeAssignment( SingleCellDimension scd, int numberOfCellTypes, double sparsity ) {
        List<Characteristic> cellTypes = new ArrayList<>();
        for ( int i = 0; i < numberOfCellTypes; i++ ) {
            cellTypes.add( Characteristic.Factory.newInstance( Categories.CELL_TYPE, "ct" + i, null ) );
        }
        int[] cellTypeIndices = new int[scd.getNumberOfCellIds()];
        for ( int i = 0; i < cellTypeIndices.length; i++ ) {
            if ( random.nextDouble() <= sparsity ) {
                cellTypeIndices[i] = CellTypeAssignment.UNKNOWN_CELL_TYPE;
            } else {
                cellTypeIndices[i] = random.nextInt( 10 );
            }
        }
        return CellTypeAssignment.Factory.newInstance( "", cellTypes, cellTypeIndices );
    }

    private static void setRandomFloatData( SingleCellExpressionDataVector vector, QuantitationType qt, int step, int N ) {
        float[] X = new float[N];
        int[] IX = new int[X.length];
        for ( int i = 0; i < N; i++ ) {
            X[i] = RandomDataUtils.sampleFloat( qt );
            IX[i] = ( i * step ) + random.nextInt( step );
        }
        vector.setDataAsFloats( X );
        vector.setDataIndices( IX );
    }

    private static void setRandomDoubleData( SingleCellExpressionDataVector vector, QuantitationType qt, int step, int N ) {
        double[] X = new double[N];
        int[] IX = new int[X.length];
        for ( int i = 0; i < N; i++ ) {
            X[i] = RandomDataUtils.sampleDouble( qt );
            IX[i] = ( i * step ) + random.nextInt( step );
        }
        vector.setDataAsDoubles( X );
        vector.setDataIndices( IX );
    }

    private static void setRandomIntData( SingleCellExpressionDataVector vector, QuantitationType qt, int step, int N ) {
        int[] X = new int[N];
        int[] IX = new int[X.length];
        for ( int i = 0; i < N; i++ ) {
            X[i] = RandomDataUtils.sampleInt( qt );
            IX[i] = ( i * step ) + random.nextInt( step );
        }
        vector.setDataAsInts( X );
        vector.setDataIndices( IX );
    }

    private static void setRandomLongData( SingleCellExpressionDataVector vector, QuantitationType qt, int step, int N ) {
        long[] X = new long[N];
        int[] IX = new int[X.length];
        for ( int i = 0; i < N; i++ ) {
            X[i] = RandomDataUtils.sampleLong( qt );
            IX[i] = ( i * step ) + random.nextInt( step );
        }
        vector.setDataAsLongs( X );
        vector.setDataIndices( IX );
    }

    private static SingleCellDimension createDimension( ExpressionExperiment ee, int numCellsPerBioAssay ) {
        List<BioAssay> samples = ee.getBioAssays().stream()
                // for reproducibility
                .sorted( Comparator.comparing( BioAssay::getName ) )
                .collect( Collectors.toList() );
        int numCells = numCellsPerBioAssay * ee.getBioAssays().size();
        SingleCellDimension dimension = new SingleCellDimension();
        dimension.setCellIds( IntStream.rangeClosed( 1, numCells ).mapToObj( Integer::toString ).collect( Collectors.toList() ) );
        dimension.setNumberOfCellIds( numCells );
        dimension.setBioAssays( samples );
        int[] offsets = new int[samples.size()];
        for ( int i = 0; i < samples.size(); i++ ) {
            offsets[i] = i * numCellsPerBioAssay;
        }
        dimension.setBioAssaysOffset( offsets );
        return dimension;
    }
}
